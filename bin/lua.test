#!/usr/bin/env levee

-- vim: set ft=lua:

function dirname(str)
	if str:match(".-/.-") then
		local name = string.gsub(str, "(.*/)(.*)", "%1")
		return name
	else
		return ''
	end
end

local path = dirname(arg[0])

package.path = string.format(
	'./?/init.lua;%s/?.lua;%s/?/init.lua;%s/../?/init.lua;%s',
		path, path, path, package.path)

local math = require('math')
local io = require('io')
local os = require('os')

-- setup global variables
assert = require('luassert')
debug = require('debug')

function repr(x, indent)
	indent = indent or ""
	local s
	if type(x) == "table" then
		s = "{\n"
		local i, v = next(x)
		while i do
			s = s .. indent .. "    " .. repr(i) .. " = " .. repr(v, indent.."    ")
			i, v = next(x, i)
			if i then s = s .. ",\n" end

		end
		return s .. "}"

	elseif type(x) == "string" then
		return '"'..x..'"'

	else
		return tostring(x)
	end
end


local usage = [[
Usage: lua.test [-v] [-x] [-k <match>] <path>]]


function bad_usage()
	print(usage)
	os.exit(1)
end


function parse_argv()
	local argv = {}

	local i = 1

	while i <= #arg do
		if arg[i] == "-v" then
			argv.verbose = 1

		elseif arg[i] == "-x" then
			argv.exitfirst = 1

		elseif arg[i] == "-k" then
			i = i + 1
			if not arg[i] then bad_usage() end
			argv.match = arg[i]

		else
			if argv.path then bad_usage() end
			argv.path = arg[i]
		end

		i = i + 1
	end

	if not argv.path then bad_usage() end

	return argv
end


function scan(path)
	local command = ('find %s -type f -name "*.lua"'):format(path)
	return io.popen(command):lines()
end


local txtblk='\27[0;30m' -- Black - Regular
local txtred='\27[0;31m' -- Red
local txtgrn='\27[0;32m' -- Green
local txtylw='\27[0;33m' -- Yellow
local txtblu='\27[0;34m' -- Blue
local txtpur='\27[0;35m' -- Purple
local txtcyn='\27[0;36m' -- Cyan
local txtwht='\27[0;37m' -- White
local bldblk='\27[1;30m' -- Black - Bold
local bldred='\27[1;31m' -- Red
local bldgrn='\27[1;32m' -- Green
local bldylw='\27[1;33m' -- Yellow
local bldblu='\27[1;34m' -- Blue
local bldpur='\27[1;35m' -- Purple
local bldcyn='\27[1;36m' -- Cyan
local bldwht='\27[1;37m' -- White
local unkblk='\27[4;30m' -- Black - Underline
local undred='\27[4;31m' -- Red
local undgrn='\27[4;32m' -- Green
local undylw='\27[4;33m' -- Yellow
local undblu='\27[4;34m' -- Blue
local undpur='\27[4;35m' -- Purple
local undcyn='\27[4;36m' -- Cyan
local undwht='\27[4;37m' -- White
local bakblk='\27[40m'   -- Black - Background
local bakred='\27[41m'   -- Red
local bakgrn='\27[42m'   -- Green
local bakylw='\27[43m'   -- Yellow
local bakblu='\27[44m'   -- Blue
local bakpur='\27[45m'   -- Purple
local bakcyn='\27[46m'   -- Cyan
local bakwht='\27[47m'   -- White
local txtrst='\27[0m'    -- Text Reset


local COLORS = {
	PASS = txtgrn,
	SKIP = txtylw,
	FAIL = txtred, }


local Writer_mt = {}
Writer_mt.__index = Writer_mt

function Writer_mt:__call(verbose, terse)
	if self.v then
		if verbose then io.write(verbose) end
	else
		if terse then io.write(terse) end
	end
	io.flush()
end

function Writer_mt:once(...)
	if not self.once then
		self(...)
		self.once = true
	end
end

function Writer_mt:notfirst(...)
	if self._notfirst then
		self(...)
	end
	self._notfirst = true
end

function Writer(verbose)
	local self = setmetatable({}, Writer_mt)
	self.v = verbose
	return self
end


function main(argv)
	local w = Writer(argv.verbose)
	local stats = setmetatable({}, {__index = function() return 0 end})
	local status = 0
	local scripts = {}

	local len = 0
	for name in scan(argv.path) do
		table.insert(scripts, name)
		len = math.max(#name, len)
	end

	table.sort(scripts)
	local base = "%-"..len.."s "

	for script in scan(argv.path) do
		local traceback
		local M = assert(loadfile(script))()

		local SKIP = (M.skipif or function() end)()

		local len = 0
		local to_run = {}
		for name in pairs(M) do
			if name:sub(0, 5) == "test_" then
				if argv.match and not string.find(name, argv.match) then
				else
					table.insert(to_run, name)
					len = math.max(#name, len)
				end
			end
		end

		if #to_run > 0 then
			table.sort(to_run)
			w:notfirst("\n")
			w(txtblu..script..txtrst..'\n')
		end

		local done = false

		for i, name in ipairs(to_run) do
			local pattern = "    %-40s "
			w(pattern:format(name))
			local success, extra
			if SKIP then
				success, extra = true, "SKIP"
			else
				success, extra = xpcall(M[name],
					function(err)
						w(
							txtred..' FAIL'..txtrst..'\n'..
							'-----\n'..
							debug.traceback()..'\n'..
							err..'\n')
						status = 1
						stats.FAIL = stats.FAIL + 1
					end)
			end
			if success and extra ~= 'IGNORE' then
				if not extra then extra = 'PASS' end
				w(
					(COLORS[extra] or txtred)..' '..extra..txtrst..'\n',
					extra == 'PASS' and '.' or extra:sub(1, 1))
				stats[extra] = stats[extra] + 1
			else
				if argv.exitfirst then
					done = true
					break
				end
			end
		end

		if done then break end
	end

	io.write('\n')
	for key, value in pairs(stats) do
		io.write(COLORS[key] or txtred, key, txtrst, '=', value, ' ')
	end
	io.write('\n')

	return status
end


os.exit(main(parse_argv()))
