#!./build/bin/levee


function dirname(str)
	if str:match(".-/.-") then
		local name = string.gsub(str, "(.*/)(.*)", "%1")
		return name
	else
		return ''
	end
end

local path = dirname(arg[0])

package.path = string.format(
	'%s/?.lua;%s/?/init.lua;%s/../?/init.lua;%s', path, path, path, package.path)

local math = require('math')
local io = require('io')
local os = require('os')

-- setup global variables
assert = require('luassert')
debug = require('debug')

function repr(x)
	local s
	if type(x) == "table" then
		s = "{"
		local i, v = next(x)
		while i do
			s = s .. repr(i) .. "=" .. repr(v)
			i, v = next(x, i)
			if i then s = s .. ", " end
		end
		return s .. "}"
	else
		return tostring(x)
	end
end


local usage = [[
Usage: lua.test [-v] [-k <match>] <path>]]


function bad_usage()
	print(usage)
	os.exit(1)
end


function parse_argv()
	local argv = {}

	local i = 1

	while i <= #arg do
		if arg[i] == "-v" then
			argv.verbose = 1

		elseif arg[i] == "-k" then
			i = i + 1
			if not arg[i] then bad_usage() end
			argv.match = arg[i]

		else
			if argv.path then bad_usage() end
			argv.path = arg[i]
		end

		i = i + 1
	end

	if not argv.path then bad_usage() end

	return argv
end


function scan(path)
	local command = ('find %s -type f -name "*.lua"'):format(path)
	return io.popen(command):lines()
end


txtblk='\27[0;30m' -- Black - Regular
txtred='\27[0;31m' -- Red
txtgrn='\27[0;32m' -- Green
txtylw='\27[0;33m' -- Yellow
txtblu='\27[0;34m' -- Blue
txtpur='\27[0;35m' -- Purple
txtcyn='\27[0;36m' -- Cyan
txtwht='\27[0;37m' -- White
bldblk='\27[1;30m' -- Black - Bold
bldred='\27[1;31m' -- Red
bldgrn='\27[1;32m' -- Green
bldylw='\27[1;33m' -- Yellow
bldblu='\27[1;34m' -- Blue
bldpur='\27[1;35m' -- Purple
bldcyn='\27[1;36m' -- Cyan
bldwht='\27[1;37m' -- White
unkblk='\27[4;30m' -- Black - Underline
undred='\27[4;31m' -- Red
undgrn='\27[4;32m' -- Green
undylw='\27[4;33m' -- Yellow
undblu='\27[4;34m' -- Blue
undpur='\27[4;35m' -- Purple
undcyn='\27[4;36m' -- Cyan
undwht='\27[4;37m' -- White
bakblk='\27[40m'   -- Black - Background
bakred='\27[41m'   -- Red
bakgrn='\27[42m'   -- Green
bakylw='\27[43m'   -- Yellow
bakblu='\27[44m'   -- Blue
bakpur='\27[45m'   -- Purple
bakcyn='\27[46m'   -- Cyan
bakwht='\27[47m'   -- White
txtrst='\27[0m'    -- Text Reset


local Writer_mt = {}
Writer_mt.__index = Writer_mt

function Writer_mt:__call(verbose, terse)
	if self.v then
		if verbose then io.write(verbose) end
	else
		if terse then io.write(terse) end
	end
	io.flush()
end

function Writer_mt:once(...)
	if not self.once then
		self(...)
		self.once = true
	end
end

function Writer_mt:notfirst(...)
	if self._notfirst then
		self(...)
	end
	self._notfirst = true
end

function Writer(verbose)
	local self = setmetatable({}, Writer_mt)
	self.v = verbose
	return self
end


function main(argv)
	local w = Writer(argv.verbose)
	local status = 0
	local scripts = {}

	local len = 0
	for name in scan(argv.path) do
		table.insert(scripts, name)
		len = math.max(#name, len)
	end

	table.sort(scripts)
	local base = "%-"..len.."s "

	for script in scan(argv.path) do
		local traceback
		local M = assert(loadfile(script))()

		local skipped = 0
		local len = 0
		local to_run = {}
		for name in pairs(M) do
			if argv.match and not string.find(name, argv.match) then
				skipped = skipped + 1
			else
				table.insert(to_run, name)
				len = math.max(#name, len)
			end
		end

		if #to_run > 0 then
			table.sort(to_run)
			w:notfirst("\n")
			w(txtblu..script..txtrst..'\n')
		end

		for i, name in ipairs(to_run) do
			local pattern = "    %-40s "
			w(pattern:format(name))
			local success, extra = xpcall(M[name],
				function(err)
					w(
						txtred..' FAIL'..txtrst..'\n'..
						'-----\n'..
						debug.traceback()..'\n'..
						err..'\n')
					status = 1
				end)
			if success then
				if not extra then extra = 'PASS' end
				local COLORS = {
					PASS = txtgrn,
					SKIP = txtylw, }
				w(
					(COLORS[extra] or txtred)..' '..extra..txtrst..'\n',
					'.')
			end
		end
	end

	w(nil, '\n')

	return status
end


os.exit(main(parse_argv()))
