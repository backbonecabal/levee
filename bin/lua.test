#!./build/bin/levee


function dirname(str)
	if str:match(".-/.-") then
		local name = string.gsub(str, "(.*/)(.*)", "%1")
		return name
	else
		return ''
	end
end

local path = dirname(arg[0])

package.path = string.format(
	'%s/?.lua;%s/?/init.lua;%s/../?/init.lua;%s', path, path, path, package.path)

local math = require('math')
local io = require('io')
local os = require('os')

-- setup global variables
assert = require('luassert')
debug = require('debug')


local usage = [[
Usage: lua.test [-k <match>] <path>]]


function bad_usage()
	print(usage)
	os.exit(1)
end


function parse_argv()
	local path
	local match

	local i = 1

	while i <= #arg do
		if arg[i] == "-k" then
			i = i + 1
			if not arg[i] then bad_usage() end
			match = arg[i]

		else
			if path then bad_usage() end
			path = arg[i]
		end

		i = i + 1
	end

	if not path then bad_usage() end

	return {path = path, match = match}
end


function scan(path)
	local command = ('find %s -type f -name "*.lua"'):format(path)
	return io.popen(command):lines()
end


txtblk='\27[0;30m' -- Black - Regular
txtred='\27[0;31m' -- Red
txtgrn='\27[0;32m' -- Green
txtylw='\27[0;33m' -- Yellow
txtblu='\27[0;34m' -- Blue
txtpur='\27[0;35m' -- Purple
txtcyn='\27[0;36m' -- Cyan
txtwht='\27[0;37m' -- White
bldblk='\27[1;30m' -- Black - Bold
bldred='\27[1;31m' -- Red
bldgrn='\27[1;32m' -- Green
bldylw='\27[1;33m' -- Yellow
bldblu='\27[1;34m' -- Blue
bldpur='\27[1;35m' -- Purple
bldcyn='\27[1;36m' -- Cyan
bldwht='\27[1;37m' -- White
unkblk='\27[4;30m' -- Black - Underline
undred='\27[4;31m' -- Red
undgrn='\27[4;32m' -- Green
undylw='\27[4;33m' -- Yellow
undblu='\27[4;34m' -- Blue
undpur='\27[4;35m' -- Purple
undcyn='\27[4;36m' -- Cyan
undwht='\27[4;37m' -- White
bakblk='\27[40m'   -- Black - Background
bakred='\27[41m'   -- Red
bakgrn='\27[42m'   -- Green
bakylw='\27[43m'   -- Yellow
bakblu='\27[44m'   -- Blue
bakpur='\27[45m'   -- Purple
bakcyn='\27[46m'   -- Cyan
bakwht='\27[47m'   -- White
txtrst='\27[0m'    -- Text Reset


function main(argv)
	local status = 0

	local scripts = {}

	local len = 0
	for name in scan(argv.path) do
		table.insert(scripts, name)
		len = math.max(#name, len)
	end

	table.sort(scripts)
	local base = "%-"..len.."s "

	for script in scan(argv.path) do
		local traceback
		local M = assert(loadfile(script))()

		local skipped = 0
		local len = 0
		local to_run = {}
		for name in pairs(M) do
			if argv.match and not string.find(name, argv.match) then
				skipped = skipped + 1
			else
				table.insert(to_run, name)
				len = math.max(#name, len)
			end
		end

		table.sort(to_run)
		local pattern = "  %-40s "

		print()
		print(txtblu..script..txtrst)

		for i, name in ipairs(to_run) do
			io.write(pattern:format(name))
			local success = xpcall(M[name],
				function(err)
					print(txtred..' FAIL'..txtrst)
					print('-----')
					print(debug.traceback())
					print(err)
					print()
					status = 1
				end)
			if success then
				print(txtgrn..' PASS'..txtrst)
			end
		end
	end

	return status
end


os.exit(main(parse_argv()))
