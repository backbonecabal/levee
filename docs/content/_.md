## _: General library functions

### Path

* procname(s):
	returns `err`, `s` where `s` is a string for the currently running process.

* dirname(s):
	returns the directory name of the path `s`.

* basename(s):
	returns the base name of the path `s`.

### Random

* rand.integer(bound):

* rand.bytes(len):

* rand.number():

### Argv

### Time

### System Calls

#### Files

* open(path, flags...):
	opens file `path` with `flags`. returns `err`, `no` where `no` is the file
	descriptor of the opened file.

* pipe():
	creates a read / write pair of file descriptors. returns `err`, `r`, `w`.

* write(no, buf, len):
	attempts to write `len` bytes of `buf` to file descriptor `no`. if `len` is
	`nil` then length of `buf` will be attempted to detected. returns `err`, `n`
	where `n` is the number of bytes written.

* read(no, buf, len):
	attempts to read `len` bytes into `buf` from file descriptor `no`. `len`
	defaults to sizeof `buf`. returns `err`, `n` where `n` is the number of bytes
	read.

* reads(no, len):
	attempts to read `len` bytes from file descriptor `no`. `len`
	defaults to 4096. returns `err`, `str` where `str` is the string read.

* close(no):
	closes file descriptor `no`. returns `err`.

* stat(path):
	returns `err`, `statinfo` for the file pointed to by path where `statinfo` is
	a `Stat` object.

* fstat(no):
	returns `err`, `statinfo` for the file known by the opened file descriptor
	`no`  where `statinfo` is a `Stat` object.

* fcntl(no, cmd, ...):
	call fcntl. returns `err`, `flags`

* fcntl_nonblock(no):
	convenience to set file descriptor `no` status to non-blocking. returns
	`err`.

* fcntl_block(no):
	convenience to set file descriptor `no` status to blocking. returns `err`.

* poller():
  returns a `Poller` object

#### Network

* getaddrinfo(host, port):
	returns `err`, `info`, `ptr` where `info` is a pointer to the allocated
	sockaddr info array, to be used to later free and `ptr` is a pointer for
	iterating the sockaddr info array.
	TODO: I think we can rework this so freeaddrinfo is called automatically be
	gc

* getsockname(no):
	return `err`, `endpoint` where `endpoint` is an `Endpoint` object

* getpeername(no):
	return `err`, `endpoint` where `endpoint` is an `Endpoint` object

* listen(domain, type_, host, port):
	creates a listening socket. returns `err`, `no` where `no` is the file
	descriptor of the created socket.

* connect(host, port):
	attempts to connect to `host`, `port` and returns `err`, `no` where `no` is
	the file descriptor for the connected socket.

#### Processes

* execv(path, argv):

* execvp(name, argv):

* waitpid(pid, options):

* set_pdeathsig():

### Objects

#### Stat

Information about a file.

##### methods

* is_reg():
	returns `true` if this is a regular file

* is_dir():
	returns `true` if this is a directory

#### Endpoint

Provides access to a sockaddr

##### methods

* port():
	returns `port`

#### Poller

##### methods

* abstime(rel):
	use the poller's internal timer to convert a relative time `rel` to an
	absolute time.

* reltime(abs):
	use the poller's internal timer to convert an absolute time `abs` to a
	relative time.

* register(no, r, w):
* unregister(no, r, w):

* signal_clear(no):
* signal_register(no):
* signal_unregister(no):

* poll(timeout):
	`timeout` is an absolute unix timestamp. returns `events`, `n` where `events`
	is an array of `PollerEvent` objects and `n` is the number of events in the
	array.

#### PollerEvent

##### methods

* value():
	returns `no`, `user`, `signal`, `r`, `w`, `e` where `no` is either the file
	descriptor or signal number of the event. `user` will be true if this is a
	user event. `signal` will be true if this is a signal event. `r` will be true
	if the is a file read event. `w` will be true if this a file write event. and
	`e` will be true if an error signal has been raised on a file descriptor.
